# Спецкурс по языку Ява  
# Лабораторная работа 2
Создать класс, реализующий работу с векторами (набор вещественных чисел, координат)
и базовые операции векторной арифметики. Класс должен удовлетворять следующим
требованиям.  
Экземпляр должен соответствовать вектору фиксированной длины (она задается как
параметр конструктора). Конструктор без параметра не создавать.
Должны быть реализованы следующие методы:
доступа к элементам вектора (получения значения и изменения значения),
получения «длины» вектора (количества его элементов),
поиска минимального и максимального значений из элементов вектора,
сортировки вектора (по возрастанию или убыванию – на ваш выбор),
нахождения евклидовой нормы, умножения вектора на число,
сложения двух векторов (статический), нахождения скалярного произведения двух векторов (статический).  
* Примечание 1. В процессе выполнения задания НЕЛЬЗЯ пользоваться утилитными
классами Java (кроме метода Math.sqrt()).
* Примечание 2. Выполнять задание нужно в среде разработки.
# Лабораторная работа 3  
1. Описать два класса с идентичным внешним контрактом, принадлежащих одной
предметной области (функциональная семантика предметной области выбирается
самостоятельно). Оба класса должны содержать:  
-поле – массив, поле строкового типа, поле целого типа, возможно добавление других
необходимых полей;  
-конструктор по умолчанию, и конструктор с параметрами, позволяющими полностью
инициализировать объект;  
-методы доступа к элементам массива и к полям;  
-бизнес-метод, реализующий некоторую функцию от элементов массива и полей
объектов классов (арифметическую, логическую, конкатенацию и т.п.).  
2. Описать интерфейс, задающий список сигнатур методов доступа к полям объектов и
функционального метода, оба класса должны реализовывать интерфейс.  
3. В классах корректно переопределить методы класса Object – toString(), equals(),
hashCode().  
4. Разработать программное приложение, имеющее адекватный интерфейс пользователя,
в котором организовать базу (массив) объектов типа интерфейс и заполнить ее объектами
описанных типов вперемежку (по желанию пользователя приложения). Выполнить
следующие действия:  
- вывести полную информацию обо всех объектах массива;  
- найти в массиве объекты, бизнес-метод которых возвращают одинаковый результат,
поместить такие объекты в другие массивы (в новых массивах хранятся объекты из исходной
балы, имеющие одинаковый результат выполнения бизнес-метода);  
- разбить исходный массив на два массива, в которых будут храниться однотипные
элементы (проверять реальный тип объекта);  
5. При описании классов описать собственные исключения - одно объявляемое
(наследное от Exception) и одно необъявляемое (наследное от RuntimeException) исключения,
характеризующие ошибки, связанные с выполнением методов классов и учитывающие
специфику исключения (объявляемость и необъявляемость). Обычно объявляемое
исключение связано с логикой работы метода, поэтому его, видимо, надо выбрасывать из
бизнес-метода. Необъявляемое исключение можно связать с некорректными входными
данными для методов-сеттеров. В соответствующих методах выбрасывать/при выбросе
контролировать описанные исключения.  
Пример семантики. Класс «Серия сочинений» (поле – массив хранит количество страниц
в каждой книге серии, второе поле – название серии, третье поле – количество страниц в
книге, занятых вводной информацией, бизнес-метод – подсчет общего количества страниц
серии без учета вводных страниц книг) и класс «Сборник статей» (поле – массив хранит
количество страниц каждой статьи, второе поле – название сборника, третье поле –
максимально допустимое количество страниц для аннотации статьи, бизнес-метод – подсчет
общего количества страниц без учета аннотаций статей). Необъявляемые исключение –
невалидные значения в параметрах конструкторов и методов доступа (неположительная
длина массива, несуществующий индекс в массиве, недопустимое значение поля, etc.),
объявляемое исключение – ошибка бизнес-метода.
# Лабораторная работа 4  
Задание 1  
Модифицировать классы из лабораторной работы No3 следующим образом:  
-в интерфейс добавить следующие методы:  
-- записи в байтовый поток  
void output(OutputStream out);  
-- записи в символьный поток  
void write(Writer out);  
-реализовать добавленные в интерфейс методы в обоих классах вашей иерархии;  
-описать новый класс со следующими статическими методами:  
-- записи в байтовый поток  
void output<Интерфейс>(<Интерфейс> o, OutputStream out);  
-- чтения из байтового потока  
<Интерфейс> input<Интерфейс>(InputStream in);  
-- записи в символьный поток  
void write<Интерфейс> (<Интерфейс> o, Writer out);  
-- чтения из символьного потока  
<Интерфейс> read<Интерфейс>(Reader in);  
В статических методах записи делегировать вызов соответствующему методу
интерфейса.  
В обоих случаях записанный объект должен представлять собой последовательность
значений своих полей.  
В случае символьного потока рекомендуется считать, что один объект записывается в
одну строку (поля разделены пробелами). Для чтения элемента из символьного потока
можно использовать класс StreamTokenizer.  
Задание 2  
Модифицировать классы в иерархии таким образом, чтобы они были сериализуемы.
Добавить в класс со статическими методами методы для вывода/ввода сериализованных
объектов.  
-- вывод сериализованных объектов  
void serialize<Интерфейс> (<Интерфейс> o, OutputStream out);  
-- ввод десериализованного объекта  
<Интерфейс> deserialize<Интерфейс>(InputStream in);  
Задание 3  
Добавить в класс со статическими методами методы для форматного текстового ввода и
вывода.  
-- вывод с объектов  
void writeFormat<Интерфейс> (<Интерфейс> o, Writer out);  
-- ввод объекта (параметром метода является объект типа Scanner)  
<Интерфейс> readFormat<Интерфейс>(Scanner in);  
Задание 4  
Организовать примитивный интерфейс пользователя, выполняющий следующие
функции:  
- заполнение базы элементов с консоли, с выбором типа элемента пользователем;  
- цикл записи в байтовый поток и цикл чтения из байтового потока базы элементов с
помощью разработанных в задании 1 методов байтового ввода/вывода;  
- цикл записи в текстовый поток и цикл чтения из текстового потока базы элементов с
помощью разработанных в задании 1 методов текстового ввода/вывода;  
- цикл записи в байтовый поток и цикл чтения из байтового потока базы элементов с
помощью разработанных в задании 2 методов сериализации/десериализации;  
- цикл записи в текстовый поток и цикл чтения из текстового потока базы элементов с
помощью разработанных в задании 3 методов текстового форматного ввода/вывода
(возможны особенности преобразования вещественных чисел, необходимо задать нужную
настройку локали).  
Протестировать разработанные методы работы с потоками, а также возможности  
сериализации. В качестве источника и получателя данных использовать файлы.
# Лабораторная работа 5  
Задание 1  
Создать два класса нитей, наследующих от класса Thread, взаимодействующих друг с
другом с помощью одного промежуточного объекта типа интерфейс из вашей иерархии (см
л.р. No3).  
Первая нить последовательно заполняет поле-массив промежуточного объекта
(изначально он заполнен значениями по умолчанию) произвольными различными
величинами (например, случайными), отличными от нуля. Каждый раз, когда она помещает
значение в массив, она выводит на экран сообщение вида “Write: ### to position
###”. По достижении конца массива нить заканчивает свое выполнение.
Вторая нить последовательно считывает значения из массива и выводит их на экран
сообщениями вида “Read: ### from position ###”. По достижении конца массива
нить заканчивает свое выполнение.  
В методе main() следует создать 3 участвующих в процессе объекта (две нити и объект
интерфейса для записи/чтения в него) и запустить нити на выполнение. Запустите программу
несколько раз. Попробуйте варьировать приоритеты нитей.  
Задание 2  
Создайте два новых класса нитей (реализуют интерфейс Runnable), обеспечивающих
последовательность операций чтения-записи (т.е. на экран сообщения выводятся в порядке
write-read-write-read-...) независимо от приоритетов потоков. Для этого потребуется описать
некий вспомогательный класс <Интерфейс>Synchronizer, объект которого и будет
использоваться при взаимодействии нитей. Сообщения на экране, выводимые объектом-
посредником, должны соответствовать формату в задании 1. Протестируйте работу
описанных классов так же, как и в задании 1.  
Задание 3  
Добавить в класс со статическими методами обработки объектов (созданный в л. р. 4)
реализацию метода <Интерфейс> synchronized<Интерфейс> (<Интерфейс> i),
возвращающего ссылку на оболочку указанного интерфейса, безопасную с точки зрения
многопоточности. Для этого потребуется описать новый класс, реализующий ваш интерфейс
<Интерфейс> и представляющий собой оболочку, синхронизирующую все методы
интерфейса (состоящую из синхронизированных методов вашего интерфейса).
Протестировать его работу.
